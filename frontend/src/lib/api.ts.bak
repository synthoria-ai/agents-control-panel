// API Configuration
const API_BASE = import.meta.env.VITE_API_BASE_URL || 'https://agents.nnr.buzz';
const API_KEY = import.meta.env.VITE_WEBHOOK_API_KEY || '';

// Type definitions for API responses
export interface Agent {
  id: string;
  name: string;
  description: string;
  status: 'active' | 'inactive';
  type: 'scheduled' | 'webhook';
  model: string;
  temperature: number;
  enabled?: boolean;
  schedule?: string | null;
  skills_file?: string;
  config?: any;
  created_at?: string;
  updated_at?: string;
  lastExecuted?: string;
  executionCount?: number;
  successRate?: number;
}

export interface Execution {
  id: string;
  agent_name: string;
  agentName?: string;
  agentId?: string;
  status: 'completed' | 'failed' | 'running' | 'success' | 'error' | 'pending';
  start_time: string;
  startTime?: string;
  end_time?: string | null;
  endTime?: string | null;
  duration?: number | null;
  result?: any;
  output?: any;
  error?: string | null;
  logs?: string | null;
  tokens_used?: number;
  tokens?: number;
  cost?: number;
}

export interface ExecutionStatus {
  executionId: string;
  status: 'completed' | 'failed' | 'running';
  agentName: string;
  startTime: string;
  endTime?: string;
  duration?: number;
  output?: any;
  error?: string;
  logs?: string;
}

export interface PipelineStatus {
  pipelineId: string;
  status: 'completed' | 'failed' | 'running';
  steps: string[];
  currentStep?: string;
  results?: any;
  error?: string;
}

// Global fetch wrapper with authentication
async function authenticatedFetch(url: string, options: RequestInit = {}) {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
    ...(options.headers as Record<string, string> || {}),
  };

  // Add API key if available
  if (API_KEY) {
    headers['x-api-key'] = API_KEY;
  }

  const response = await fetch(url, {
    ...options,
    headers,
  });

  if (!response.ok) {
    let errorMessage = `API Error: ${response.status}`;
    try {
      const errorData = await response.json();
      errorMessage = errorData.error || errorData.message || errorMessage;
    } catch {
      errorMessage = await response.text() || errorMessage;
    }
    throw new Error(errorMessage);
  }

  return response.json();
}

// Map backend agent data to frontend format
function mapAgentData(backendAgent: any): Agent {
  return {
    id: backendAgent.id?.toString() || backendAgent.name,
    name: backendAgent.name,
    description: backendAgent.description,
    status: backendAgent.enabled !== false ? 'active' : 'inactive',
    type: backendAgent.type || 'webhook',
    model: backendAgent.model || 'unknown',
    temperature: backendAgent.temperature || 0.7,
    enabled: backendAgent.enabled,
    schedule: backendAgent.schedule,
    skills_file: backendAgent.skills_file,
    config: backendAgent.config,
    created_at: backendAgent.created_at,
    updated_at: backendAgent.updated_at,
  };
}

// Map backend execution data to frontend format
function mapExecutionData(backendExecution: any): Execution {
  const statusMap: Record<string, 'success' | 'error' | 'pending'> = {
    'completed': 'success',
    'failed': 'error',
    'running': 'pending',
  };

  return {
    id: backendExecution.id,
    agent_name: backendExecution.agent_name,
    agentName: backendExecution.agent_name,
    agentId: backendExecution.agent_name,
    status: statusMap[backendExecution.status] || backendExecution.status,
    start_time: backendExecution.start_time,
    startTime: backendExecution.start_time,
    end_time: backendExecution.end_time,
    endTime: backendExecution.end_time,
    duration: backendExecution.duration,
    result: backendExecution.result,
    output: backendExecution.result,
    error: backendExecution.error,
    logs: backendExecution.logs,
    tokens_used: backendExecution.tokens_used,
    tokens: backendExecution.tokens_used,
    cost: backendExecution.cost,
  };
}

// API Client
export const api = {
  // Get all agents
  get: async (endpoint: string) => {
    if (endpoint === '/agents') {
      const response = await authenticatedFetch(`${API_BASE}/api/agents`);
      // Backend returns { success: true, data: [...], count: N }
      if (response.data && Array.isArray(response.data)) {
        return response.data.map(mapAgentData);
      }
      // Fallback for direct array response
      return Array.isArray(response) ? response.map(mapAgentData) : [];
    }

    // Get single agent
    if (endpoint.startsWith('/agents/')) {
      const agentId = endpoint.split('/')[2];
      const response = await authenticatedFetch(`${API_BASE}/api/agents`);
      const agents = response.data || response;
      const agent = agents.find((a: any) => a.id?.toString() === agentId || a.name === agentId);
      return agent ? mapAgentData(agent) : null;
    }

    // Get all executions
    if (endpoint === '/executions') {
      const response = await authenticatedFetch(`${API_BASE}/api/executions`);
      if (response.data && Array.isArray(response.data)) {
        return response.data.map(mapExecutionData);
      }
      return Array.isArray(response) ? response.map(mapExecutionData) : [];
    }

    // Get single execution
    if (endpoint.startsWith('/executions/')) {
      const executionId = endpoint.split('/')[2];
      const response = await authenticatedFetch(
        `${API_BASE}/api/webhooks/n8n/execution-status/${executionId}`
      );
      return mapExecutionData(response);
    }

    // Fallback for other endpoints
    return authenticatedFetch(`${API_BASE}${endpoint}`);
  },

  // Execute an agent
  post: async (endpoint: string, data?: any) => {
    // Execute agent endpoint
    if (endpoint.includes('/execute')) {
      const agentName = data?.agentName || data?.name;
      const input = data?.input || {};
      
      const response = await authenticatedFetch(
        `${API_BASE}/api/webhooks/n8n/execute-agent`,
        {
          method: 'POST',
          body: JSON.stringify({
            agentName,
            input,
            options: data?.options || {},
          }),
        }
      );
      
      return response;
    }

    // Create agent (not implemented)
    if (endpoint === '/agents') {
      throw new Error('Agent creation is not yet implemented in the backend');
    }

    // Fallback for other POST requests
    return authenticatedFetch(`${API_BASE}${endpoint}`, {
      method: 'POST',
      body: JSON.stringify(data),
    });
  },

  // Update agent (not implemented)
  put: async (endpoint: string, data?: any) => {
    if (endpoint.startsWith('/agents/')) {
      throw new Error('Agent updates are not yet implemented in the backend');
    }

    return authenticatedFetch(`${API_BASE}${endpoint}`, {
      method: 'PUT',
      body: JSON.stringify(data),
    });
  },

  // Delete agent (not implemented)
  delete: async (endpoint: string) => {
    if (endpoint.startsWith('/agents/')) {
      throw new Error('Agent deletion is not yet implemented in the backend');
    }

    return authenticatedFetch(`${API_BASE}${endpoint}`, {
      method: 'DELETE',
    });
  },

  // Get execution status (for polling)
  getExecutionStatus: async (executionId: string): Promise<ExecutionStatus> => {
    return authenticatedFetch(
      `${API_BASE}/api/webhooks/n8n/execution-status/${executionId}`
    );
  },

  // Get pipeline status
  getPipelineStatus: async (pipelineId: string): Promise<PipelineStatus> => {
    return authenticatedFetch(
      `${API_BASE}/api/webhooks/n8n/pipeline-status/${pipelineId}`
    );
  },

  // Execute agent (direct method)
  executeAgent: async (agentName: string, input?: any, options?: any) => {
    return authenticatedFetch(
      `${API_BASE}/api/webhooks/n8n/execute-agent`,
      {
        method: 'POST',
        body: JSON.stringify({
          agentName,
          input: input || {},
          options: options || {},
        }),
      }
    );
  },

  // Trigger content pipeline
  triggerPipeline: async (brand: string, options?: any) => {
    return authenticatedFetch(
      `${API_BASE}/api/webhooks/n8n/content-pipeline`,
      {
        method: 'POST',
        body: JSON.stringify({
          brand,
          options: options || {},
        }),
      }
    );
  },
};

// Export helper functions
export { mapAgentData, mapExecutionData };
